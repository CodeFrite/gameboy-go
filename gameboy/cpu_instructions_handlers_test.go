package gameboy

import (
	"fmt"
	"reflect"
	"testing"
)

/*

Feature non CB instructions
===========================

Test Cases List:

- TC1> NOP: should not change anything in the gameboy except the program counter and the clock
- TC2> STOP: should stop the gameboy (not implemented yet)
- TC3> HALT: should halt the gameboy by setting the HALT flag to true
- TC4> DI: should disable interrupts by setting the IME flag to false
- TC5> EI: should enable interrupts by setting the IME flag to true
- TC6> JP: should jump to the address specified in the instruction
- TC7> JR: should jump to the address specified in the instruction
- TC8> CALL: should call the address specified in the instruction
- TC9> RET: should return from a subroutine
- TC10> RETI: should return from a subroutine and enable interrupts
- TC11> RST: should call the address specified in the instruction
- TC12> LD: should load the value from the source into the destination
- TC13> LDH: should load the value from the source into the destination
- TC14> PUSH: should push the value from the source into the stack
- TC15> POP: should pop the value from the stack into the destination
- TC16> ADD: should add the value from the source to the destination
- TC17> ADC: should add the value from the source to the destination with the carry
- TC18> AND: should perform a bitwise AND between the source and the destination
- TC19> INC: should increment the value of the destination
- TC20> CCF: should flip the carry flag
- TC21> CP: should compare the value from the source to the destination
- TC22> CPL: should flip all bits of the destination
- TC23> DAA: should adjust the destination to be a valid BCD number
- TC24> DEC: should decrement the value of the destination
- TC25> SUB: should subtract the value from the source to the destination
- TC26> SBC: should subtract the value from the source to the destination with the carry
- TC27> SCF: should set the carry flag
- TC28> OR: should perform a bitwise OR between the source and the destination
- TC29> XOR: should perform a bitwise XOR between the source and the destination
- TC30> RLA: should rotate the destination left through the carry
- TC31> RLCA: should rotate the destination left
- TC32> RRA: should rotate the destination right through the carry
- TC33> RRCA: should rotate the destination right

*/

// global variables
var (
	bus     *Bus
	memory1 *Memory
	memory2 *Memory
	cpu     *CPU

	cpuState1 *CpuState
	cpuState2 *CpuState
)

/* SUPPORT FUNCs */

// allow func to panic without stopping the test
func mayPanic(f func()) (panicked bool) {
	defer func() {
		if r := recover(); r != nil {
			panicked = true
		}
	}()
	f()
	return
}

// initialize the test environment with the following preconditions:
// create a bus /
// create two 8KB memory and attach them to the bus /
// create a cpu
// initialize the cpu states
func preconditions() {
	// create a bus
	bus = NewBus()
	// create a first memory and attach it to the bus
	memory1 = NewMemory(0x2000)
	bus.AttachMemory("RAM 1", 0x0000, memory1)
	// create a second memory and attach it to the bus
	memory2 = NewMemory(0xDFFF)
	bus.AttachMemory("RAM 2", 0x2000, memory2)
	// create IE memory and attach it to the bus
	ie := NewMemory(0x0001)
	bus.AttachMemory("IE", 0xFFFF, ie)

	// create a cpu
	cpu = NewCPU(bus)
	cpu.pc = 0x0000
	cpu.sp = 0xFFFE
	cpu.halted = false
	cpu.stopped = false

	// initialize the cpu states
	cpuState := getCpuState()
	cpuState1 = cpuState
	cpuState2 = cpuState
}

// clean up the test environment by setting all the variables to nil
func postconditions() {
	// clean up
	bus = nil
	memory1 = nil
	memory2 = nil
	cpu = nil
	cpuState1 = nil
	cpuState2 = nil
}

// save the state of the cpu
func getCpuState() *CpuState {
	return &CpuState{
		PC:            cpu.pc,
		SP:            cpu.sp,
		A:             cpu.a,
		F:             cpu.f,
		Z:             cpu.f&0x80 != 0,
		N:             cpu.f&0x40 != 0,
		H:             cpu.f&0x20 != 0,
		C:             cpu.f&0x10 != 0,
		BC:            uint16(cpu.b)<<8 | uint16(cpu.c),
		DE:            uint16(cpu.d)<<8 | uint16(cpu.e),
		HL:            uint16(cpu.h)<<8 | uint16(cpu.l),
		PREFIXED:      cpu.prefixed,
		IR:            cpu.ir,
		OPERAND_VALUE: cpu.operand,
		IE:            cpu.GetIEFlag(),
		IME:           cpu.ime,
		HALTED:        cpu.halted,
	}
}

func printCpuState(cpuState *CpuState) {
	fmt.Println(" ***   *** *** ***   *** ***   ***   *** *** ***   ***   *** ***   *** *** ***   ***")
	fmt.Println("CPU STATE:")
	fmt.Printf("PC: 0x%04X\n", cpuState.PC)
	fmt.Printf("SP: 0x%04X\n", cpuState.SP)
	fmt.Printf("A: 0x%02X\n", cpuState.A)
	fmt.Printf("F: 0x%02X\n", cpuState.F)
	fmt.Printf("Z: %t\n", cpuState.Z)
	fmt.Printf("N: %t\n", cpuState.N)
	fmt.Printf("H: %t\n", cpuState.H)
	fmt.Printf("C: %t\n", cpuState.C)
	fmt.Printf("BC: 0x%04X\n", cpuState.BC)
	fmt.Printf("DE: 0x%04X\n", cpuState.DE)
	fmt.Printf("HL: 0x%04X\n", cpuState.HL)
	fmt.Printf("PREFIXED: %t\n", cpuState.PREFIXED)
	fmt.Printf("IR: 0x%02X\n", cpuState.IR)
	fmt.Printf("OPERAND_VALUE: 0x%02X\n", cpuState.OPERAND_VALUE)
	fmt.Println("IE:", cpuState.IE)
	fmt.Println("IME:", cpuState.IME)
	fmt.Println("HALTED:", cpuState.HALTED)
}

// shift the state of the cpu from mem1 to mem2
func shiftCpuState(mem1 *CpuState, mem2 *CpuState) {
	*mem2 = CpuState{
		PC:            mem1.PC,
		SP:            mem1.SP,
		A:             mem1.A,
		F:             mem1.F,
		Z:             mem1.Z,
		N:             mem1.N,
		H:             mem1.H,
		C:             mem1.C,
		BC:            mem1.BC,
		DE:            mem1.DE,
		HL:            mem1.HL,
		PREFIXED:      mem1.PREFIXED,
		IR:            mem1.IR,
		OPERAND_VALUE: mem1.OPERAND_VALUE,
		IE:            mem1.IE,
		IME:           mem1.IME,
		HALTED:        mem1.HALTED,
	}
}

// load program into the memory starting from the address 0x0000
func loadProgramIntoMemory(memory *Memory, program []uint8) {
	for idx, val := range program {
		memory.Write(uint16(idx), val)
	}
}

func compareCpuState(mem1 *CpuState, mem2 *CpuState) []string {
	result := make([]string, 0)
	// Loop over the fields of the CpuState struct
	v1 := reflect.ValueOf(*mem1)
	v2 := reflect.ValueOf(*mem2)
	typeOfS := v1.Type()

	for i := 0; i < v1.NumField(); i++ {
		fieldName := typeOfS.Field(i).Name
		val1 := v1.Field(i).Interface()
		val2 := v2.Field(i).Interface()
		if fieldName != "INSTRUCTION" && val1 != val2 {
			result = append(result, fieldName)
		}
	}
	return result
}

func printMemoryProperties() {
	memoryMaps := bus.mmu.GetMemoryMaps()
	fmt.Println("\n> Memory Mapping:")
	fmt.Println("-----------------")
	for _, memoryMap := range memoryMaps {
		fmt.Printf("> Memory %s: %d bytes @ 0x%04X->0x%04X\n", memoryMap.Name, len(memoryMap.Data), memoryMap.Address, memoryMap.Address+uint16(len(memoryMap.Data))-1)
	}
}

/* TEST CASES */

/* TC1: should not change anything in the gameboy except the program counter and the clock */

func TestNOP(t *testing.T) {
	preconditions()

	// test program : 0xFF NOP instructions
	var testData []uint8 = make([]uint8, 0xFF)
	for i := 0; i < 0x0F; i++ {
		testData[i] = 0x00
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// shift mem1 to mem2
	cpu.Step()
	shiftCpuState(cpuState1, cpuState2)

	for i := 0; i < len(testData); i++ {
		// execute the next instruction and shift the saved state mem1 to mem2 and save the new state in mem1
		shiftCpuState(cpuState1, cpuState2)
		cpu.Step()
		cpuState1 = getCpuState()
		cmp := compareCpuState(cpuState1, cpuState2)
		// check if there is only one difference between the two states: PC incremented to i
		if len(cmp) != 1 {
			t.Errorf("[NOP_TC1_CHK_1] Error> NOP instruction should change exactly one field, the PC. Here got %v", cmp)
		} else {

			// the key should be PC
			if cmp[0] != "PC" {
				t.Errorf("[NOP_TC1_CHK_2] Error> NOP instruction should change the PC field, here got %v\n", cmp[0])
			}

			// PC should be equal to 0x0E
			if cpuState1.PC != uint16(i+1) {
				t.Errorf("[NOP_TC1_CHK_3] Error> NOP instruction should increment the PC by 1, here got %v\n", cpuState1.PC)
			}
		}
	}

	postconditions()
}

/* TC2: should stop the gameboy */
func TestSTOP(t *testing.T) {
	preconditions()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check if the gameboy is halted on the STOP instruction
	if !cpu.stopped {
		t.Errorf("[STOP_TC1_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}
	finalState := getCpuState()
	// check if the last PC = 0x0005, position of the STOP instruction in the test data program
	if finalState.PC != 0x0005 {
		t.Errorf("[STOP_TC1_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x0005, got @0x%X4 \n", finalState.PC)
	}

	/*
		// debugging output
		printCpuState(finalState)
	*/

	postconditions()
}

/* TC3: should halt the gameboy by setting the HALT flag to true */
func TestHALT(t *testing.T) {
	preconditions()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check if the gameboy is halted on the HALT instruction
	if !cpu.halted {
		t.Errorf("[HALT_TC1_CHK_1] Error> HALT instruction should halt the gameboy\n")
	}
	finalState := getCpuState()
	// check if the last PC = 0x0001, position of the HALT instruction in the test data program
	if finalState.PC != 0x0005 {
		t.Errorf("[HALT_TC1_CHK_2] Error> HALT instruction: the program counter should have stopped at the HALT instruction\n")
	}

	postconditions()
}

/* TC4: should disable interrupts by setting the IME flag to false */
func TestDI(t *testing.T) {
	preconditions()
	cpu.ime = true

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program and control step by step the IME flag
	for i := 0; i < len(testData); i++ {
		cpu.Step()
		/*
			// debugging output
			fmt.Println()
			fmt.Println(" ***   *** *** ***   *** ***   ***   *** *** ***   ***   *** ***   *** *** ***   ***")
			fmt.Println(i, ">")
			printCpuState(getCpuState())
		*/

		// the IME flag should stay up until the end of the execution after the DI instruction
		if i >= 0 && i <= 5 {
			if !cpu.ime {
				t.Errorf("[DI_TC1_CHK_1] Error> DI instruction should disable the IME flag after the execution of the next instruction\n")
			}
		} else if i >= 6 {
			if cpu.ime {
				t.Errorf("[DI_TC1_CHK_2] Error> DI instruction should disable the IME flag\n")
			}
		}
	}

	postconditions()
}

/* TC5: should enable interrupts by setting the IME flag to true */
func TestEI(t *testing.T) {
	preconditions()
	cpu.ime = false

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program and control step by step the IME flag
	for i := 0; i < len(testData); i++ {
		cpu.Step()
		/*
			// debugging output
			fmt.Println()
			fmt.Println(" ***   *** *** ***   *** ***   ***   *** *** ***   ***   *** ***   *** *** ***   ***")
			fmt.Println(i, ">")
			printCpuState(getCpuState())
		*/
		// the IME flag should stay down until the end of the execution after the EI instruction
		if i >= 0 && i <= 5 {
			if cpu.ime {
				t.Errorf("[EI_TC1_CHK_1] Error> EI instruction should enable the IME flag after the execution of the next instruction\n")
			}
		} else if i >= 6 {
			if !cpu.ime {
				t.Errorf("[EI_TC1_CHK_2] Error> EI instruction should enable the IME flag\n")
			}
		}
	}

	postconditions()
}

// TC6: should jump to the address specified in the instruction
// opcodes:
//   - 0xC3 = JP     a16
//   - 0xE9 = JP HL
//   - 0xCA = JP  Z, a16
//   - 0xC2 = JP NZ, a16
//   - 0xDA = JP  C, a16
//   - 0xD2 = JP NC, a16
//   - flags: -
func TestJP(t *testing.T) {

	/*
	 * TC1: positive cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JP a16 / JP HL / JP Z, a16 / JP C, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JP a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JP HL ; precondition: HL = 0x00D0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xDA, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		JP C, a16(0x00B0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xCA, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		JP Z, a16(0x0040)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xC3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		JP a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00B0 {
		t.Errorf("[JP_TC1_CHK_1] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x00B0, got @0x%X4 \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[JP_TC1_CHK_2] Error> JP instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	/*
	 * TC2: negative cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JP a16 / JP HL / JP NZ, a16 / JP NC, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JP a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JP HL ; precondition: HL = 0x00D0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xD2, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		JP NC, a16(0x00B0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xC2, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		JP NZ, a16(0x0040)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xC3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		JP a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[JP_TC1_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00B0 {
		t.Errorf("[JP_TC1_CHK_2] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x00B0, got @0x%X4 \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[JP_TC1_CHK_3] Error> JP instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

}

// TC7: should jump to the address specified in the instruction
// Jumps to a relative address from the next instruction
//
//	opcodes:
//	- 0x18 = JR r8
//	- 0x20 = JR NZ, r8
//	- 0x28 = JR Z, r8
//	- 0x30 = JR NC, r8
//	- 0x38 = JR C, r8
//	- flags: -
func TestJR(t *testing.T) {
	/*
	 * TC1: positive cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JR a16 / JR HL / JR Z, a16 / JR C, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x28, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR Z, r8(0x40) ; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x18, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  	; step 1	;		JR r8(255 - 32 = 223 = DF) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x28, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  	; step 3	;		JR Z, r8(0x40)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  	; step 4	;		JR C, r8(0x40) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x38, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  	; step 5	;   JR C, r8(0x60) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x38, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  	; step 6	;   JR C, r8(255-80 = 175 = AF) ; precondition: C = 0
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[JP_TC1_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[JP_TC1_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%X4 \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[JP_TC1_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	/*
	 * TC2: negative cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JR a16 / JR HL / JR NZ, a16 / JR NC, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x20, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR NZ, r8(0x40) ; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x18, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8(255 - 32 = 223 = DF) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x20, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR NZ, r8(0x40)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR NC, r8(0x40) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x30, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR NC, r8(0x60) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x30, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR NC, r8(255-80 = 175 = AF) ; precondition: C = 0
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[JP_TC2_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[JP_TC2_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%X4 \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[JP_TC2_CHK_2] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}

// TC8: should call the address specified in the instruction
// opcodes:
//   - 0xCD = CALL a16
//   - 0xCC = CALL Z, a16
//   - 0xC4 = CALL NZ, a16
//   - 0xDC = CALL C, a16
//   - 0xD4 = CALL NC, a16
//   - flags: -
func TestCALL(t *testing.T) {
	/*
	 * TC1: positive cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions CALL a16 / CALL HL / CALL Z, a16 / CALL C, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCD, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xCC, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL Z, a16(0x00D0) ; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xDC, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		CALL C, a16(0x00B0) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 6	;		STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0xDC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   CALL C, a16(0x0060) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xCC, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		CALL Z, a16(0x0040)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		CALL a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[CALL_TC1_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x0060 {
		t.Errorf("[CALL_TC1_CHK_2] Error> CALL instruction: the program counter should have stopped at the STOP instruction @0x0060, got @0x%X4 \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[CALL_TC1_CHK_3] Error> CALL instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	/*
	 * TC2: negative cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions CALL a16 / CALL HL / CALL NZ, a16 / CALL NC, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCD, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xC4, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL NZ, a16(0x00D0) ; precondition: Z = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xD4, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		CALL NC, a16(0x00B0) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 6	;		STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0xD4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   CALL NC, a16(0x0060) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xC4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		CALL NZ, a16(0x0040) ; precondition: Z = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		CALL a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[CALL_TC2_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x0060 {
		t.Errorf("[CALL_TC2_CHK_2] Error> CALL instruction: the program counter should have stopped at the STOP instruction @0x0060, got @0x%X4 \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[CALL_TC2_CHK_3] Error> CALL instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}

// TC9: should return from a subroutine : Will call 3 func and return from them in reverse order
// opcodes:
//   - 0xC9 = RET
//   - 0xC8 = RET Z
//   - 0xC0 = RET NZ
//   - 0xD8 = RET C
//   - 0xD0 = RET NC
//   - flags: - - - -
func TestRET(t *testing.T) {

	/* TC1: RET */

	// preconditions
	preconditions()

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[RET_TC1_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%X4 \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RET_TC1_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%X4 \n", finalState.SP)
	}

	// postconditions
	postconditions()

	/* TC2: RET Z */

	// preconditions
	preconditions()
	cpu.f = 0x80 // Z = 1 / C = 0 / H = 0 / N = 0

	// prepare the test data
	testData = []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[RET_TC2_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%X4 \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RET_TC2_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%X4 \n", finalState.SP)
	}

	// postconditions
	postconditions()

	/* TC3: RET NZ */

	// preconditions
	preconditions()
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0

	// prepare the test data
	testData = []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[RET_TC3_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%X4 \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RET_TC3_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%X4 \n", finalState.SP)
	}

	// postconditions
	postconditions()

	/* TC4: RET C */

	// preconditions
	preconditions()
	cpu.f = 0xFF // Z = 0 / C = 1 / H = 0 / N = 0

	// prepare the test data
	testData = []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[RET_TC4_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%X4 \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RET_TC4_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%X4 \n", finalState.SP)
	}

	// postconditions
	postconditions()

	/* TC5: RET NC */

	// preconditions
	preconditions()
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0

	// prepare the test data
	testData = []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[RET_TC5_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%X4 \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RET_TC5_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%X4 \n", finalState.SP)
	}

	// postconditions
	postconditions()
}

// TC10: should return from a subroutine and enable interrupts
// 0xD9 = RETI
func TestRETI(t *testing.T) {
	// preconditions
	preconditions()
	bus.Write(0xFFFF, 0x00) // disable interrupts IME=0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP ; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RETI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP ; CALL 0x00C9 : RETI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RETI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP; start program here with RETI ; precondition: SP = 0x0080 [0x60, 0x00]
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[RETI_TC1_CHK_1] Error> RETI instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%X4 \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RETI_TC1_CHK_2] Error> RETI instruction: the stack pointer should have stopped at 0xFFFE, got @0x%X4 \n", finalState.SP)
	}

	// check if the IME = 1
	if !finalState.IME {
		t.Errorf("[RETI_TC1_CHK_3] Error> RETI instruction: the interrupt master enable flag should have been set\n")
	}

	// postconditions
	postconditions()
}

// TC11: should call the address specified in the instruction
// opcodes:
//   - 0xC7 = RST $00
//   - 0xCF = RST $08
//   - 0xD7 = RST $10
//   - 0xDF = RST $18
//   - 0xE7 = RST $20
//   - 0xEF = RST $28
//   - 0xF7 = RST $30
//   - 0xFF = RST $38
//   - flags: - - - -
func TestRST(t *testing.T) {

	/* TC1: RST - we start @0x00F0 and execute:
	 * - @0xF0 RST $38
	 */

	// preconditions
	preconditions()
	cpu.offset = 0x00F0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7 *0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @000X	; 				; RET ; RST $00 ; RET
		0x00, 0xCF, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @001X	; RST $00 ; RET ; RST $10	; RET
		0x00, 0xDF, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @002X	; RST $18 ; RET ; RST $20	; RET
		0x00, 0xEF, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @003X	; RST $28 ; RET ; RST $30	; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, // @00FX	; RST $38 ; STOP
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x00FE {
		t.Errorf("[RST_TC1_CHK_1] Error> RST instruction: the program counter should have stopped at the STOP instruction @0x00FE, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[RST_TC1_CHK_2] Error> RST instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}

/* TC12: should load the value from the source into the destination */
func TestLD(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC13: should load the value from the source into the destination and not impact the flags */
func Test_0xF0_LDH_A__a8(t *testing.T) {
	preconditions()

	// print A initial value
	getCpuState().print()

	// set flags to some arbitrary values to check if they are not impacted by the instruction
	cpu.f = 0xE5

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0xF0, 0x77, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// the instruction LDH will look @0xFF77 for the value to load into A. Let's set this value to 0xB5
	bus.Write(0xFF77, 0xB5)

	//printMemoryProperties()

	// run the program and control step by step the IME flag
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	finalState.print()

	// program should have stopped at 0x0005
	if finalState.PC != 0x0005 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_0] Error> LDH A, (a8) instruction: the program counter should have stopped at 0x0005, got 0x%04X \n", finalState.PC)
	}

	// A should be 0xB5
	if finalState.A != 0xB5 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_1] Error> LDH A, (a8) instruction: the A register should have been set to 0xB5, got 0x%02X \n", finalState.A)
	}

	// check if the flags are not impacted
	if finalState.F != 0xE5 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_2] Error> LDH A, (a8) instruction: the flags should not have been impacted, got 0x%02X \n", finalState.F)
	}

	postconditions()

}

func Test_0xE0_LDH__a8_A(t *testing.T) {
	preconditions()

	// set flags to some arbitrary values to check if they are not impacted by the instruction
	cpu.f = 0xE5

	// set the value of A to 0xB5
	cpu.a = 0xB5

	// print A initial value
	getCpuState().print()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0xE0, 0x77, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	//printMemoryProperties()

	// run the program and control step by step the IME flag
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	finalState.print()

	// program should have stopped at 0x0005
	if finalState.PC != 0x0005 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_0] Error> LDH (a8), A instruction: the program counter should have stopped at 0x0005, got 0x%04X \n", finalState.PC)
	}

	// [FF77] should be 0xB5
	inMemoryValue := bus.Read(0xFF77)
	if inMemoryValue != 0xB5 {
		t.Errorf("[0xF0_LDH__a8_A_TC13_CHK_1] Error> LDH (a8), A instruction: the memory location @0x77 should have been set to 0xB5, got 0x%02X \n", inMemoryValue)
	}

	// check if the flags are not impacted
	if finalState.F != 0xE5 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_2] Error> LDH (a8), A instruction: the flags should not have been impacted, got 0x%02X \n", finalState.F)
	}

	postconditions()
}

/* TC14: should push the value from the source into the stack */
func TestPUSH(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC15: should pop the value from the stack into the destination */
func TestPOP(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC16: should add the value from the source to the destination */
func TestADD(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC17: should add the value from the source to the destination with the carry */
func TestADC(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC18: should perform a bitwise AND between the source and the destination */
func TestAND(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC19: should increment the value of the destination */
func TestINC(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC20: should flip the carry flag */
func TestCCF(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC21: should compare the value from the source to the destination */
func TestCP(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC22: should flip all bits of the destination */
func TestCPL(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC23: should adjust the destination to be a valid BCD number */
func TestDAA(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC24: should decrement the value of the destination */
func TestDEC(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC25: should subtract the value from the source to the destination */
func TestSUB(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC26: should subtract the value from the source to the destination with the carry */
func TestSBC(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC27: should set the carry flag */
func TestSCF(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC28: should perform a bitwise OR between the source and the destination */
func TestOR(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC29: should perform a bitwise XOR between the source and the destination */
func TestXOR(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC30: should rotate the destination left through the carry */
func TestRLA(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC31: should rotate the destination left */
func TestRLCA(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC32: should rotate the destination right through the carry */
func TestRRA(t *testing.T) {
	t.Skip("not implemented yet")
}

/* TC33: should rotate the destination right */
func TestRRCA(t *testing.T) {
	t.Skip("not implemented yet")
}
