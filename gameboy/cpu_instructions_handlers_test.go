package gameboy

import (
	"fmt"
	"reflect"
	"testing"
)

/*

Testing non CB instructions
===========================

Test Cases List:

- NOP: should not change anything in the gameboy except the program counter and the clock
- STOP: should stop the gameboy (not implemented yet)
- HALT: should halt the gameboy by setting the HALT flag to true
- DI: should disable interrupts by setting the IME flag to false
- EI: should enable interrupts by setting the IME flag to true
- JP: should jump to the address specified in the instruction
- JR: should jump to the address specified in the instruction
- CALL: should call the address specified in the instruction
- RET: should return from a subroutine
- RETI: should return from a subroutine and enable interrupts
- RST: should call the address specified in the instruction
- LD: should load the value from the source into the destination
- LDH: should load the value from the source into the destination
- PUSH: should push the value from the source into the stack
- POP: should pop the value from the stack into the destination
- ADD: should add the value from the source to the destination
- ADC: should add the value from the source to the destination with the carry
- AND: should perform a bitwise AND between the source and the destination
- INC: should increment the value of the destination
- CCF: should flip the carry flag
- CP: should compare the value from the source to the destination
- CPL: should flip all bits of the destination
- DAA: should adjust the destination to be a valid BCD number
- DEC: should decrement the value of the destination
- SUB: should subtract the value from the source to the destination
- SBC: should subtract the value from the source to the destination with the carry
- SCF: should set the carry flag
- OR: should perform a bitwise OR between the source and the destination
- XOR: should perform a bitwise XOR between the source and the destination
- RLA: should rotate the destination left through the carry
- RLCA: should rotate the destination left
- RRA: should rotate the destination right through the carry
- RRCA: should rotate the destination right

*/

// global variables
var (
	bus     *Bus
	memory1 *Memory
	memory2 *Memory
	cpu     *CPU

	cpuState1 *CpuState
	cpuState2 *CpuState
)

/* SUPPORT FUNCs */

// allow func to panic without stopping the test
func mayPanic(f func()) (panicked bool) {
	defer func() {
		if r := recover(); r != nil {
			panicked = true
		}
	}()
	f()
	return
}

// initialize the test environment with the following preconditions:
// create a bus /
// create two 8KB memory and attach them to the bus /
// create a cpu
// initialize the cpu states
func preconditions() {
	// create a bus
	bus = NewBus()
	// create a first memory and attach it to the bus
	memory1 = NewMemory(0x2000)
	bus.AttachMemory("RAM 1", 0x0000, memory1)
	// create a second memory and attach it to the bus
	memory2 = NewMemory(0xDFFF)
	bus.AttachMemory("RAM 2", 0x2000, memory2)
	// create IE memory and attach it to the bus
	ie := NewMemory(0x0001)
	bus.AttachMemory("IE", 0xFFFF, ie)

	// create a cpu
	cpu = NewCPU(bus)
	cpu.pc = 0x0000
	cpu.sp = 0xFFFE
	cpu.halted = false
	cpu.stopped = false

	// initialize the cpu states
	cpuState := getCpuState()
	cpuState1 = cpuState
	cpuState2 = cpuState
}

// clean up the test environment by setting all the variables to nil
func postconditions() {
	// clean up
	bus = nil
	memory1 = nil
	memory2 = nil
	cpu = nil
	cpuState1 = nil
	cpuState2 = nil
}

// save the state of the cpu
func getCpuState() *CpuState {
	return &CpuState{
		PC:            cpu.pc,
		SP:            cpu.sp,
		A:             cpu.a,
		F:             cpu.f,
		Z:             cpu.f&0x80 != 0,
		N:             cpu.f&0x40 != 0,
		H:             cpu.f&0x20 != 0,
		C:             cpu.f&0x10 != 0,
		BC:            uint16(cpu.b)<<8 | uint16(cpu.c),
		DE:            uint16(cpu.d)<<8 | uint16(cpu.e),
		HL:            uint16(cpu.h)<<8 | uint16(cpu.l),
		PREFIXED:      cpu.prefixed,
		IR:            cpu.ir,
		OPERAND_VALUE: cpu.operand,
		IE:            cpu.GetIEFlag(),
		IME:           cpu.ime,
		HALTED:        cpu.halted,
	}
}

func printCpuState(cpuState *CpuState) {
	fmt.Println(" ***   *** *** ***   *** ***   ***   *** *** ***   ***   *** ***   *** *** ***   ***")
	fmt.Println("CPU STATE:")
	fmt.Printf("PC: 0x%04X\n", cpuState.PC)
	fmt.Printf("SP: 0x%04X\n", cpuState.SP)
	fmt.Printf("A: 0x%02X\n", cpuState.A)
	fmt.Printf("F: 0x%02X\n", cpuState.F)
	fmt.Printf("Z: %t\n", cpuState.Z)
	fmt.Printf("N: %t\n", cpuState.N)
	fmt.Printf("H: %t\n", cpuState.H)
	fmt.Printf("C: %t\n", cpuState.C)
	fmt.Printf("BC: 0x%04X\n", cpuState.BC)
	fmt.Printf("DE: 0x%04X\n", cpuState.DE)
	fmt.Printf("HL: 0x%04X\n", cpuState.HL)
	fmt.Printf("PREFIXED: %t\n", cpuState.PREFIXED)
	fmt.Printf("IR: 0x%02X\n", cpuState.IR)
	fmt.Printf("OPERAND_VALUE: 0x%02X\n", cpuState.OPERAND_VALUE)
	fmt.Println("IE:", cpuState.IE)
	fmt.Println("IME:", cpuState.IME)
	fmt.Println("HALTED:", cpuState.HALTED)
}

// shift the state of the cpu from mem1 to mem2
func shiftCpuState(mem1 *CpuState, mem2 *CpuState) {
	*mem2 = CpuState{
		PC:            mem1.PC,
		SP:            mem1.SP,
		A:             mem1.A,
		F:             mem1.F,
		Z:             mem1.Z,
		N:             mem1.N,
		H:             mem1.H,
		C:             mem1.C,
		BC:            mem1.BC,
		DE:            mem1.DE,
		HL:            mem1.HL,
		PREFIXED:      mem1.PREFIXED,
		IR:            mem1.IR,
		OPERAND_VALUE: mem1.OPERAND_VALUE,
		IE:            mem1.IE,
		IME:           mem1.IME,
		HALTED:        mem1.HALTED,
	}
}

// load program into the memory starting from the address 0x0000
func loadProgramIntoMemory(memory *Memory, program []uint8) {
	for idx, val := range program {
		memory.Write(uint16(idx), val)
	}
}

func compareCpuState(mem1 *CpuState, mem2 *CpuState) []string {
	result := make([]string, 0)
	// Loop over the fields of the CpuState struct
	v1 := reflect.ValueOf(*mem1)
	v2 := reflect.ValueOf(*mem2)
	typeOfS := v1.Type()

	for i := 0; i < v1.NumField(); i++ {
		fieldName := typeOfS.Field(i).Name
		val1 := v1.Field(i).Interface()
		val2 := v2.Field(i).Interface()
		if fieldName != "INSTRUCTION" && val1 != val2 {
			result = append(result, fieldName)
		}
	}
	return result
}

func printMemoryProperties() {
	memoryMaps := bus.mmu.GetMemoryMaps()
	fmt.Println("\n> Memory Mapping:")
	fmt.Println("-----------------")
	for _, memoryMap := range memoryMaps {
		fmt.Printf("> Memory %s: %d bytes @ 0x%04X->0x%04X\n", memoryMap.Name, len(memoryMap.Data), memoryMap.Address, memoryMap.Address+uint16(len(memoryMap.Data))-1)
	}
}

// TEST CASES

// NOP: should not change anything in the gameboy except the program counter and the clock
func TestNOP(t *testing.T) {
	preconditions()

	// test program : 0xFF NOP instructions
	var testData []uint8 = make([]uint8, 0xFF)
	for i := 0; i < 0x0F; i++ {
		testData[i] = 0x00
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// shift mem1 to mem2
	cpu.Step()
	shiftCpuState(cpuState1, cpuState2)

	for i := 0; i < len(testData); i++ {
		// execute the next instruction and shift the saved state mem1 to mem2 and save the new state in mem1
		shiftCpuState(cpuState1, cpuState2)
		cpu.Step()
		cpuState1 = getCpuState()
		cmp := compareCpuState(cpuState1, cpuState2)
		// check if there is only one difference between the two states: PC incremented to i
		if len(cmp) != 1 {
			t.Errorf("[TestNOP_CHK_1] Error> NOP instruction should change exactly one field, the PC. Here got %v", cmp)
		} else {

			// the key should be PC
			if cmp[0] != "PC" {
				t.Errorf("[TestNOP_CHK_2] Error> NOP instruction should change the PC field, here got %v\n", cmp[0])
			}

			// PC should be equal to 0x0E
			if cpuState1.PC != uint16(i+1) {
				t.Errorf("[TestNOP_CHK_3] Error> NOP instruction should increment the PC by 1, here got %v\n", cpuState1.PC)
			}
		}
		// NOP instruction shouldn't change the flags
		if cpuState1.F != cpuState2.F {
			t.Errorf("[TestNOP_CHK_4] Error> NOP instruction shouldn't change the flags\n")
		}
	}

	postconditions()
}

// STOP: should stop the gameboy
func TestSTOP(t *testing.T) {
	preconditions()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check if the gameboy is halted on the STOP instruction
	if !cpu.stopped {
		t.Errorf("[TestSTOP_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}
	finalState := getCpuState()
	// check if the last PC = 0x0005, position of the STOP instruction in the test data program
	if finalState.PC != 0x0005 {
		t.Errorf("[TestSTOP_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x0005, got @0x%04X \n", finalState.PC)
	}

	/*
		// debugging output
		printCpuState(finalState)
	*/

	postconditions()
}

// HALT: should halt the gameboy by setting the HALT flag to true
func TestHALT(t *testing.T) {
	preconditions()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check if the gameboy is halted on the HALT instruction
	if !cpu.halted {
		t.Errorf("[TestHALT_CHK_1] Error> HALT instruction should halt the gameboy\n")
	}
	finalState := getCpuState()
	// check if the last PC = 0x0001, position of the HALT instruction in the test data program
	if finalState.PC != 0x0005 {
		t.Errorf("[TestHALT_CHK_2] Error> HALT instruction: the program counter should have stopped at the HALT instruction\n")
	}

	postconditions()
}

// DI: should disable interrupts by setting the IME flag to false
func TestDI(t *testing.T) {
	preconditions()
	cpu.ime = true

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program and control step by step the IME flag
	for i := 0; i < len(testData); i++ {
		cpu.Step()
		/*
			// debugging output
			fmt.Println()
			fmt.Println(" ***   *** *** ***   *** ***   ***   *** *** ***   ***   *** ***   *** *** ***   ***")
			fmt.Println(i, ">")
			printCpuState(getCpuState())
		*/

		// the IME flag should stay up until the end of the execution after the DI instruction
		if i >= 0 && i <= 5 {
			if !cpu.ime {
				t.Errorf("[TestDI_CHK_1] Error> DI instruction should disable the IME flag after the execution of the next instruction\n")
			}
		} else if i >= 6 {
			if cpu.ime {
				t.Errorf("[TestDI_CHK_2] Error> DI instruction should disable the IME flag\n")
			}
		}
	}

	postconditions()
}

// EI: should enable interrupts by setting the IME flag to true
func TestEI(t *testing.T) {
	preconditions()
	cpu.ime = false

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// run the program and control step by step the IME flag
	for i := 0; i < len(testData); i++ {
		cpu.Step()
		/*
			// debugging output
			fmt.Println()
			fmt.Println(" ***   *** *** ***   *** ***   ***   *** *** ***   ***   *** ***   *** *** ***   ***")
			fmt.Println(i, ">")
			printCpuState(getCpuState())
		*/
		// the IME flag should stay down until the end of the execution after the EI instruction
		if i >= 0 && i <= 5 {
			if cpu.ime {
				t.Errorf("[TestEI_CHK_1] Error> EI instruction should enable the IME flag after the execution of the next instruction\n")
			}
		} else if i >= 6 {
			if !cpu.ime {
				t.Errorf("[TestEI_CHK_2] Error> EI instruction should enable the IME flag\n")
			}
		}
	}

	postconditions()
}

// JP: conditional jump to the address specified in the instruction
// opcodes:
//   - 0xC2 = JP NZ, a16
//   - 0xC3 = JP     a16
//   - 0xCA = JP  Z, a16
//   - 0xD2 = JP NC, a16
//   - 0xDA = JP  C, a16
//   - 0xE9 = JP HL
//   - flags: -
func TestJP(t *testing.T) {
	t.Run("0xC2: JP NZ, a16", test_0xC2_JP_NZ_a16)
	t.Run("0xC3: JP a16", test_0xC3_JP_a16)
	t.Run("0xCA: JP Z, a16", test_0xCA_JP_Z_a16)
	t.Run("0xD2: JP NC, a16", test_0xD2_JP_NC_a16)
	t.Run("0xDA: JP C, a16", test_0xDA_JP_C_a16)
	t.Run("0xE9: JP HL", test_0xE9_JP_HL)
	t.Run("JP integration", test_JP_integration)
}
func test_0xC3_JP_a16(t *testing.T) {
	// TC1: positive case: should always jump to the a16 address specified in the 3bytes instruction
	preconditions()
	cpu.resetZFlag()
	saveFlags := cpu.f

	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x0020
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0xC3, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // jump to 0x1A
	}
	loadProgramIntoMemory(memory1, testData)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xC3_JP_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState.PC != 0x001F {
		t.Errorf("[test_0xC3_JP_a16_CHK_2] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x001F, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xC3_JP_a16_CHK_3] Error> JP instruction: no flags should have changed\n")
	}
}
func test_0xE9_JP_HL(t *testing.T) {
	// TC1: positive case: should always jump to the address stored in HL
	preconditions()
	cpu.setHL(0x0020)
	saveFlags := cpu.f

	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x0020
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x1A
	}
	loadProgramIntoMemory(memory1, testData)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xE9_JP_HL_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState.PC != 0x002F {
		t.Errorf("[test_0xE9_JP_HL_CHK_2] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x002F, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xE9_JP_HL_CHK_3] Error> JP instruction: no flags should have changed\n")
	}
}
func test_0xCA_JP_Z_a16(t *testing.T) {
	// TC1: positive case: should jump to a16 operand address if Z=1
	preconditions()
	cpu.setZFlag()
	saveFlags1 := cpu.f

	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x0020
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0xCA, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // jump to 0x1A
	}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xCA_JP_Z_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState1 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState1.PC != 0x001F {
		t.Errorf("[test_0xCA_JP_Z_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x001F, got @0x%04X \n", finalState1.PC)
	}

	// no flags should have changed
	if finalState1.F != saveFlags1 {
		t.Errorf("[test_0xCA_JP_Z_a16_CHK_3] Error> no flags should have changed\n")
	}

	// TC2: positive case: should not jump if Z=0
	preconditions()
	cpu.resetZFlag()
	saveFlags2 := cpu.f

	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // no jump // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, //
		0x00, 0x00, 0x00, 0x00, 0xCA, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xCA_JP_Z_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState2 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState2.PC != 0x000F {
		t.Errorf("[test_0xCA_JP_Z_a16_CHK_5] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x000F, got @0x%04X \n", finalState2.PC)
	}

	// no flags should have changed
	if finalState2.F != saveFlags2 {
		t.Errorf("[test_0xCA_JP_Z_a16_CHK_6] Error> JP instruction: no flags should have changed\n")
	}
}
func test_0xC2_JP_NZ_a16(t *testing.T) {
	// TC1: positive case: should jump if Z=0
	preconditions()
	cpu.resetZFlag()
	saveFlags1 := cpu.f

	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC2, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x0020
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0xC2, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // jump to 0x1A
	}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xC2_JP_NZ_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState1 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState1.PC != 0x001F {
		t.Errorf("[test_0xC2_JP_NZ_a16_CHK_2] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x001F, got @0x%04X \n", finalState1.PC)
	}

	// no flags should have changed
	if finalState1.F != saveFlags1 {
		t.Errorf("[test_0xC2_JP_NZ_a16_CHK_3] Error> JP instruction: no flags should have changed\n")
	}

	// TC2: positive case: should not jump if Z=1
	preconditions()
	cpu.setZFlag()
	saveFlags2 := cpu.f

	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC2, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // no jump // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, //
		0x00, 0x00, 0x00, 0x00, 0xC2, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xC2_JP_NZ_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState2 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState2.PC != 0x000F {
		t.Errorf("[test_0xC2_JP_NZ_a16_CHK_5] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x000F, got @0x%04X \n", finalState2.PC)
	}

	// no flags should have changed
	if finalState2.F != saveFlags2 {
		t.Errorf("[test_0xC2_JP_NZ_a16_CHK_6] Error> JP instruction: no flags should have changed\n")
	}
}
func test_0xDA_JP_C_a16(t *testing.T) {
	// TC1: positive case: should jump to a16 operand address if C flag is set
	preconditions()
	cpu.setCFlag()
	saveFlags1 := cpu.f

	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xDA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x0020
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0xDA, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // jump to 0x1A
	}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xDA_JP_C_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState1 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState1.PC != 0x001F {
		t.Errorf("[test_0xDA_JP_C_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x001F, got @0x%04X \n", finalState1.PC)
	}

	// no flags should have changed
	if finalState1.F != saveFlags1 {
		t.Errorf("[test_0xDA_JP_C_a16_CHK_3] Error> no flags should have changed\n")
	}

	// TC2: positive case: should not jump if C flag is reset
	preconditions()
	cpu.resetCFlag()
	saveFlags2 := cpu.f

	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xDA, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // no jump // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, //
		0x00, 0x00, 0x00, 0x00, 0xDA, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xDA_JP_C_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState2 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState2.PC != 0x000F {
		t.Errorf("[test_0xDA_JP_C_a16_CHK_5] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x000F, got @0x%04X \n", finalState2.PC)
	}

	// no flags should have changed
	if finalState2.F != saveFlags2 {
		t.Errorf("[test_0xDA_JP_C_a16_CHK_6] Error> JP instruction: no flags should have changed\n")
	}
}
func test_0xD2_JP_NC_a16(t *testing.T) {
	// TC1: positive case: should jump to a16 operand address if C flag is reset
	preconditions()
	cpu.resetCFlag()
	saveFlags1 := cpu.f

	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xD2, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // jump to 0x0020
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // STOP @0x1F
		0x00, 0x00, 0x00, 0x00, 0xD2, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // jump to 0x1A
	}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xD2_JP_NC_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState1 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState1.PC != 0x001F {
		t.Errorf("[test_0xD2_JP_NC_a16_CHK_2] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x001F, got @0x%04X \n", finalState1.PC)
	}

	// no flags should have changed
	if finalState1.F != saveFlags1 {
		t.Errorf("[test_0xD2_JP_NC_a16_CHK_3] Error> JP instruction: no flags should have changed\n")
	}

	// TC2: positive case: should not jump to a16 operand address if C flag is set
	preconditions()
	cpu.setCFlag()
	saveFlags2 := cpu.f

	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xD2, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // no jump // STOP @0x0F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, //
		0x00, 0x00, 0x00, 0x00, 0xD2, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
	}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x001F
	if !cpu.stopped {
		t.Errorf("[test_0xD2_JP_NC_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState2 := getCpuState()

	// check if the last PC = 0x001F, position of the STOP instruction in the test data program
	if finalState2.PC != 0x000F {
		t.Errorf("[test_0xD2_JP_NC_a16_CHK_5] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x000F, got @0x%04X \n", finalState2.PC)
	}

	// no flags should have changed
	if finalState2.F != saveFlags2 {
		t.Errorf("[test_0xD2_JP_NC_a16_CHK_6] Error> JP instruction: no flags should have changed\n")
	}
}
func test_JP_integration(t *testing.T) {

	/*
	 * TC1: positive cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JP a16 / JP HL / JP Z, a16 / JP C, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JP a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JP HL ; precondition: HL = 0x00D0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xDA, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		JP C, a16(0x00B0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xCA, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		JP Z, a16(0x0040)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xC3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		JP a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[test_JP_integration_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00B0 {
		t.Errorf("[test_JP_integration_CHK_2] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x00B0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_JP_integration_CHK_3] Error> JP instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	/*
	 * TC2: negative cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JP a16 / JP HL / JP NZ, a16 / JP NC, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JP a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JP HL ; precondition: HL = 0x00D0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xD2, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		JP NC, a16(0x00B0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xC2, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		JP NZ, a16(0x0040)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xC3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		JP a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[test_JP_integration_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00B0 {
		t.Errorf("[test_JP_integration_CHK_5] Error> JP instruction: the program counter should have stopped at the STOP instruction @0x00B0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_JP_integration_CHK_6] Error> JP instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}

// JR: should jump to the address specified in the instruction
// Jumps to a relative address from the next instruction
//
//	opcodes:
//	- 0x18 = JR r8
//	- 0x20 = JR NZ, r8
//	- 0x28 = JR Z, r8
//	- 0x30 = JR NC, r8
//	- 0x38 = JR C, r8
//	- flags: -
func TestJR(t *testing.T) {
	t.Run("0x18: JR r8", test_0x18_JR_r8)
	t.Run("0x20: JR NZ, r8", test_0x20_JR_NZ_r8)
	t.Run("0x28: JR Z, r8", test_0x28_JR_Z_r8)
	t.Run("0x30: JR NC, r8", test_0x30_JR_NC_r8)
	t.Run("0x38: JR C, r8", test_0x38_JR_C_r8)
	t.Run("JR integration", test_JR_integration)
}
func test_0x18_JR_r8(t *testing.T) {
	// TC: jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0
	// preconditions
	preconditions()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x18, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x18, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x18, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x18, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x18_JR_r8_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x18_JR_r8_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x18_JR_r8_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0x20_JR_NZ_r8(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0
	// preconditions
	preconditions()
	cpu.resetZFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x20, 0x3E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x20, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x20, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x20, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x20, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x20, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x20, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x20_JR_NZ_r8_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x20_JR_NZ_r8_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x20_JR_NZ_r8_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// should not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.resetZFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x20, 0x3E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x20, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x20, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x20, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x20, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x20, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x20, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x20_JR_NZ_r8_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x20_JR_NZ_r8_CHK_5] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x20_JR_NZ_r8_CHK_6] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0x28_JR_Z_r8(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0
	// preconditions
	preconditions()
	cpu.setZFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x28, 0x3E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x28, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x28, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x28, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x28, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x28, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x28, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x28_JR_Z_r8_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x28_JR_Z_r8_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x28_JR_Z_r8_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// should not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.setZFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x28, 0x3E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x28, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x28, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x28, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x28, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x28, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x28, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x28_JR_Z_r8_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x28_JR_Z_r8_CHK_5] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x28_JR_Z_r8_CHK_6] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0x30_JR_NC_r8(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0
	// preconditions
	preconditions()
	cpu.resetCFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x30, 0x3E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x30, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x30, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x30, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x30, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x30_JR_NC_r8_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x30_JR_NC_r8_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x30_JR_NC_r8_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// should not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.resetCFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x30, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x30, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x30, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x30, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x30_JR_NC_r8_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x30_JR_NC_r8_CHK_5] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x30_JR_NC_r8_CHK_6] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0x38_JR_C_r8(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0
	// preconditions
	preconditions()
	cpu.setCFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x38, 0x3E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x38, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x38, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x38, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x38, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x38_JR_C_r8_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x38_JR_C_r8_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x38_JR_C_r8_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// should not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.setCFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40 - 2 bytes for the instruction length)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x38, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8 (255 - 32 = 223 = DF)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x38, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR r8(0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x38, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR r8(0x60)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x38, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR r8(255-80 = 175 = AF)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0x38_JR_C_r8_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0x38_JR_C_r8_CHK_5] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0x38_JR_C_r8_CHK_6] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_JR_integration(t *testing.T) {
	/*
	 * TC1: positive cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JR a16 / JR HL / JR Z, a16 / JR C, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x28, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR Z, r8(0x40) ; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x18, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  	; step 1	;		JR r8(255 - 32 = 223 = DF) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x28, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  	; step 3	;		JR Z, r8(0x40)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x38, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  	; step 4	;		JR C, r8(0x40) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x38, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  	; step 5	;   JR C, r8(0x60) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x38, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  	; step 6	;   JR C, r8(255-80 = 175 = AF) ; precondition: C = 0
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[JP_TC1_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[JP_TC1_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[JP_TC1_CHK_3] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	/*
	 * TC2: negative cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions JR a16 / JR HL / JR NZ, a16 / JR NC, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x18, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		JR r8(+64 => 0x40)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0x20, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	JR NZ, r8(0x40) ; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0x18, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		JR r8(255 - 32 = 223 = DF) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x20, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		JR NZ, r8(0x40)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x30, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		JR NC, r8(0x40) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0x30, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   JR NC, r8(0x60) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0x30, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   JR NC, r8(255-80 = 175 = AF) ; precondition: C = 0
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[JP_TC2_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[JP_TC2_CHK_2] Error> JR instruction: the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[JP_TC2_CHK_2] Error> JR instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}

// CALL: should call the address specified in the instruction
// opcodes:
//   - 0xCD = CALL a16
//   - 0xCC = CALL Z, a16
//   - 0xC4 = CALL NZ, a16
//   - 0xDC = CALL C, a16
//   - 0xD4 = CALL NC, a16
//   - flags: -
func TestCALL(t *testing.T) {
	test_0xCD_CALL_a16(t)
	test_0xCC_CALL_Z_a16(t)
	test_0xC4_CALL_NZ_a16(t)
	test_0xDC_CALL_C_a16(t)
	test_0xD4_CALL_NC_a16(t)
	test_CALL_integration(t)
}
func test_0xCD_CALL_a16(t *testing.T) {
	// TC: jumps from 0x0000 => 0x0040 => 0x002F => 0x0060 => 0x0080 => 0x00C0 => 0x00F0 => 0x00A0 using the CALL a16 instruction
	// preconditions
	preconditions()
	saveFlags := cpu.f

	// test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCD, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL a16(0x0040)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xCD, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL a16(0x0060)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		CALL a16(0x002F)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xCD, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		CALL a16(0x0080)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xCD, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		CALL a16(0x00C0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xCD, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   CALL a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCD, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   CALL a16(0x00A0)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xCD_CALL_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0xCD_CALL_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xCD_CALL_a16_CHK_3] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0xCC_CALL_Z_a16(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x0040 => 0x002F => 0x0060 => 0x0080 => 0x00C0 => 0x00F0 => 0x00A0 using the CALL a16 instruction
	// preconditions
	preconditions()
	cpu.setZFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCC, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL Z, a16(0x0040)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xCC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL Z, a16(0x0060)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xCC, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		CALL Z, a16(0x002F)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xCC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		CALL Z, a16(0x0080)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xCC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		CALL Z, a16(0x00C0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xCC, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   CALL Z, a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCC, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   CALL Z, a16(0x00A0)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xCC_CALL_Z_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0xCC_CALL_Z_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xCC_CALL_Z_a16_CHK_3] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// does not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.resetZFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCC, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // @000X	; step 0	;		do not CALL Z, a16(0x0040) and stops @0x000F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xCC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xCC, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xCC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xCC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xCC, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCC, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xCC_CALL_Z_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x000F {
		t.Errorf("[test_0xCC_CALL_Z_a16_CHK_5] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xCC_CALL_Z_a16_CHK_6] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0xC4_CALL_NZ_a16(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x0040 => 0x002F => 0x0060 => 0x0080 => 0x00C0 => 0x00F0 => 0x00A0 using the CALL a16 instruction
	// preconditions
	preconditions()
	cpu.resetZFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL Z, a16(0x0040)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xC4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL Z, a16(0x0060)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xC4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		CALL Z, a16(0x002F)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xC4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		CALL Z, a16(0x0080)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xC4, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		CALL Z, a16(0x00C0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xC4, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   CALL Z, a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xC4, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   CALL Z, a16(0x00A0)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xC4_CALL_NZ_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0xC4_CALL_NZ_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xC4_CALL_NZ_a16_CHK_3] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// does not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.setZFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xC4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // @000X	; step 0	;		do not CALL Z, a16(0x0040) and stops @0x000F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xC4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xC4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xC4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xC4, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xC4, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xC4, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xC4_CALL_NZ_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x000F {
		t.Errorf("[test_0xC4_CALL_NZ_a16_CHK_5] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xC4_CALL_NZ_a16_CHK_6] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0xDC_CALL_C_a16(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x0040 => 0x002F => 0x0060 => 0x0080 => 0x00C0 => 0x00F0 => 0x00A0 using the CALL a16 instruction
	// preconditions
	preconditions()
	cpu.setCFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xDC, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL Z, a16(0x0040)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xDC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL Z, a16(0x0060)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xDC, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		CALL Z, a16(0x002F)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xDC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		CALL Z, a16(0x0080)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xDC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		CALL Z, a16(0x00C0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xDC, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   CALL Z, a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xDC, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   CALL Z, a16(0x00A0)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xDC_CALL_C_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0xDC_CALL_C_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xDC_CALL_C_a16_CHK_3] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// does not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.resetCFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xDC, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // @000X	; step 0	;		do not CALL Z, a16(0x0040) and stops @0x000F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xDC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xDC, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xDC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xDC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xDC, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xDC, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xDC_CALL_C_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x000F {
		t.Errorf("[test_0xDC_CALL_C_a16_CHK_5] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xDC_CALL_C_a16_CHK_6] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_0xD4_CALL_NC_a16(t *testing.T) {
	// TC1: positive case
	// jumps from 0x0000 => 0x0040 => 0x002F => 0x0060 => 0x0080 => 0x00C0 => 0x00F0 => 0x00A0 using the CALL a16 instruction
	// preconditions
	preconditions()
	cpu.resetCFlag()
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xD4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL Z, a16(0x0040)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xD4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL Z, a16(0x0060)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xD4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 1	;		CALL Z, a16(0x002F)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xD4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 3	;		CALL Z, a16(0x0080)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xD4, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X  ; step 4	;		CALL Z, a16(0x00C0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	; step 7	;   STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xD4, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX  ; step 5	;   CALL Z, a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xD4, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 6	;   CALL Z, a16(0x00A0)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xD4_CALL_NC_a16_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x00A0 {
		t.Errorf("[test_0xD4_CALL_NC_a16_CHK_2] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xD4_CALL_NC_a16_CHK_3] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()

	// TC2: negative case
	// does not jump and stop @0x000F
	// preconditions
	preconditions()
	cpu.setCFlag()
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xD4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // @000X	; step 0	;		do not CALL Z, a16(0x0040) and stops @0x000F
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xD4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xD4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0xD4, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0xD4, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX
		0xD4, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xD4, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00A0
	if !cpu.stopped {
		t.Errorf("[test_0xD4_CALL_NC_a16_CHK_4] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x000F {
		t.Errorf("[test_0xD4_CALL_NC_a16_CHK_5] Error> the program counter should have stopped at the STOP instruction @0x00A0, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[test_0xD4_CALL_NC_a16_CHK_6] Error> no flags should have changed\n")
	}

	// postconditions
	postconditions()
}
func test_CALL_integration(t *testing.T) {
	/*
	 * TC1: positive cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions CALL a16 / CALL HL / CALL Z, a16 / CALL C, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1
	saveFlags := cpu.f

	// test data
	testData1 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCD, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xCC, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL Z, a16(0x00D0) ; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xDC, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		CALL C, a16(0x00B0) ; precondition: C = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 6	;		STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0xDC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   CALL C, a16(0x0060) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xCC, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		CALL Z, a16(0x0040)	; precondition: Z = 1
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		CALL a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData1)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[CALL_TC1_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x0060 {
		t.Errorf("[CALL_TC1_CHK_2] Error> CALL instruction: the program counter should have stopped at the STOP instruction @0x0060, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[CALL_TC1_CHK_3] Error> CALL instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()

	/*
	 * TC2: negative cases
	 * jumps from 0x0000 => 0x00F0 => 0x0020 => 0x00D0 => 0x0040 => 0x00B0 using the different positive conditions CALL a16 / CALL HL / CALL NZ, a16 / CALL NC, a16
	 */

	// preconditions
	preconditions()
	cpu.h = 0x00
	cpu.l = 0xD0
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0
	saveFlags = cpu.f

	// test data
	testData2 := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0xCD, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 0	;		CALL a16(0x00F0)
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X
		0xC4, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 2	; 	CALL NZ, a16(0x00D0) ; precondition: Z = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X
		0xD4, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X  ; step 4	;		CALL NC, a16(0x00B0) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X
		0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X  ; step 6	;		STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX
		0xD4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	; step 5	;   CALL NC, a16(0x0060) ; precondition: C = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX
		0xC4, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	; step 3	;		CALL NZ, a16(0x0040) ; precondition: Z = 0
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX
		0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX  ; step 1	;		CALL a16(0x0020)
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData2)

	// run the program
	cpu.Run()

	// check if the gameboy is stopped on the STOP instruction @0x00B0
	if !cpu.stopped {
		t.Errorf("[CALL_TC2_CHK_1] Error> STOP instruction should stop the gameboy\n")
	}

	// check the final state of the cpu
	finalState = getCpuState()

	// check if the last PC = 0x00B0, position of the STOP instruction in the test data program
	if finalState.PC != 0x0060 {
		t.Errorf("[CALL_TC2_CHK_2] Error> CALL instruction: the program counter should have stopped at the STOP instruction @0x0060, got @0x%04X \n", finalState.PC)
	}

	// no flags should have changed
	if finalState.F != saveFlags {
		t.Errorf("[CALL_TC2_CHK_3] Error> CALL instruction: no flags should have changed\n")
	}

	// postconditions
	postconditions()
}

// RET: should return from a subroutine : Will call 3 func and return from them in reverse order
// opcodes:
//   - 0xC9 = RET
//   - 0xC8 = RET Z
//   - 0xC0 = RET NZ
//   - 0xD8 = RET C
//   - 0xD0 = RET NC
//
// flags: - - - -
func TestRET(t *testing.T) {
	t.Run("0xC9: RET", test_0xC9_RET)
	t.Run("0xC8: RET Z", test_0xC8_RET_Z)
	t.Run("0xC0: RET NZ", test_0xC0_RET_NZ)
	t.Run("0xD8: RET C", test_0xD8_RET_C)
	t.Run("0xD0: RET NC", test_0xD0_RET_NC)
}
func test_0xC9_RET(t *testing.T) {

	// preconditions
	preconditions()

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[test_0xC9_RET_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[test_0xC9_RET_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}
func test_0xC8_RET_Z(t *testing.T) {

	// preconditions
	preconditions()
	cpu.f = 0x80 // Z = 1 / C = 0 / H = 0 / N = 0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET Z
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[test_0xC8_RET_Z_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[test_0xC8_RET_Z_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}
func test_0xC0_RET_NZ(t *testing.T) {

	/* TC3: RET NZ */

	// preconditions
	preconditions()
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET NZ
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[test_0xC0_RET_NZ_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[test_0xC0_RET_NZ_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}
func test_0xD8_RET_C(t *testing.T) {

	/* TC4: RET C */

	// preconditions
	preconditions()
	cpu.f = 0xFF // Z = 1 / C = 1 / H = 1 / N = 1

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET C
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[test_0xD8_RET_C_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[test_0xD8_RET_C_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}
func test_0xD0_RET_NC(t *testing.T) {

	/* TC5: RET NC */

	// preconditions
	preconditions()
	cpu.f = 0x00 // Z = 0 / C = 0 / H = 0 / N = 0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP 				; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP 				; CALL 0x00C9 : RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP					; RET NC
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[test_0xD0_RET_NC_CHK_1] Error> RET instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[test_0xD0_RET_NC_CHK_2] Error> RET instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}

// RETI: should return from a subroutine and enable interrupts
// 0xD9 = RETI
func TestRETI(t *testing.T) {
	// preconditions
	preconditions()
	bus.Write(0xFFFF, 0x00) // disable interrupts IME=0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7	0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0xCD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @000X	; step 4	; NOP ; NOP ; CALL 0x0020 ; NOP ; NOP ; NOP ; STOP
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @001X	;
		0x00, 0xCD, 0x40, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @002X	; step 3	; NOP ; CALL 0x0040 ; RETI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @003X	;
		0x00, 0x00, 0xCD, 0x60, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	; step 2	; NOP ; NOP ; CALL 0x00C9 : RETI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0xCD, 0x80, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	; step 1	; NOP ; CALL 0x0080 ; RETI
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	; step 0	; NOP : NOP; start program here with RETI ; precondition: SP = 0x0080 [0x60, 0x00]
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00FX	;
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x0008 {
		t.Errorf("[TestRETI_CHK_1] Error> RETI instruction: the program counter should have stopped at the STOP instruction @0x0008, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[TestRETI_CHK_2] Error> RETI instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// check if the IME = 1
	if !finalState.IME {
		t.Errorf("[TestRETI_CHK_3] Error> RETI instruction: the interrupt master enable flag should have been set\n")
	}

	// postconditions
	postconditions()
}

// RST: should call the address specified in the instruction
// opcodes:
//   - 0xC7 = RST $00
//   - 0xCF = RST $08
//   - 0xD7 = RST $10
//   - 0xDF = RST $18
//   - 0xE7 = RST $20
//   - 0xEF = RST $28
//   - 0xF7 = RST $30
//   - 0xFF = RST $38
//   - flags: - - - -
func TestRST(t *testing.T) {

	/* TC1: RST - we start @0x00F0 and execute:
	 * - @0xF0 RST $38
	 */

	// preconditions
	preconditions()
	cpu.offset = 0x00F0

	// prepare the test data
	testData := []uint8{
		//X0	0xX1	0xX2	0xX3	0xX4	0xX5	0xX6	0xX7 *0xX8	0xX9	0xXA	0xXB	0xXC	0xXD	0xXE	0xXF
		0x00, 0x00, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @000X	; 				; RET ; RST $00 ; RET
		0x00, 0xCF, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @001X	; RST $00 ; RET ; RST $10	; RET
		0x00, 0xDF, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @002X	; RST $18 ; RET ; RST $20	; RET
		0x00, 0xEF, 0x00, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x00, // @003X	; RST $28 ; RET ; RST $30	; RET
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @004X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @005X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @006X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @007X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @008X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @009X	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00AX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00BX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00CX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00DX	;
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // @00EX	;
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, // @00FX	; RST $38 ; STOP
	}

	// load the program into the memory
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the last PC = 0x0008, position of the RET instruction in the test data program
	if finalState.PC != 0x00FE {
		t.Errorf("[TestRST_CHK_1] Error> RST instruction: the program counter should have stopped at the STOP instruction @0x00FE, got @0x%04X \n", finalState.PC)
	}

	// check if the SP = 0xFFFE
	if finalState.SP != 0xFFFE {
		t.Errorf("[TestRST_CHK_2] Error> RST instruction: the stack pointer should have stopped at 0xFFFE, got @0x%04X \n", finalState.SP)
	}

	// postconditions
	postconditions()
}

// LD: should load the value from the source into the destination
func TestLD(t *testing.T) {
	t.Skip("not implemented yet")
}

// LDH: should load the value from the source into the destination and not impact the flags
func TestLDH(t *testing.T) {
	t.Run("0xE0: LDH__a8_A", test_0xE0_LDH__a8_A)
	t.Run("0xF0: LDH_A__a8", test_0xF0_LDH_A__a8)
}
func test_0xF0_LDH_A__a8(t *testing.T) {
	preconditions()

	// print A initial value
	//getCpuState().print()

	// set flags to some arbitrary values to check if they are not impacted by the instruction
	cpu.f = 0xE5

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0xF0, 0x77, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	// the instruction LDH will look @0xFF77 for the value to load into A. Let's set this value to 0xB5
	bus.Write(0xFF77, 0xB5)

	//printMemoryProperties()

	// run the program and control step by step the IME flag
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	//finalState.print()

	// program should have stopped at 0x0005
	if finalState.PC != 0x0005 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_0] Error> LDH A, (a8) instruction: the program counter should have stopped at 0x0005, got 0x%04X \n", finalState.PC)
	}

	// A should be 0xB5
	if finalState.A != 0xB5 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_1] Error> LDH A, (a8) instruction: the A register should have been set to 0xB5, got 0x%02X \n", finalState.A)
	}

	// check if the flags are not impacted
	if finalState.F != 0xE5 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_2] Error> LDH A, (a8) instruction: the flags should not have been impacted, got 0x%02X \n", finalState.F)
	}

	postconditions()
}
func test_0xE0_LDH__a8_A(t *testing.T) {
	preconditions()

	// set flags to some arbitrary values to check if they are not impacted by the instruction
	cpu.f = 0xE5

	// set the value of A to 0xB5
	cpu.a = 0xB5

	// print A initial value
	//getCpuState().print()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0xE0, 0x77, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData)

	//printMemoryProperties()

	// run the program and control step by step the IME flag
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	//finalState.print()

	// program should have stopped at 0x0005
	if finalState.PC != 0x0005 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_0] Error> LDH (a8), A instruction: the program counter should have stopped at 0x0005, got 0x%04X \n", finalState.PC)
	}

	// [FF77] should be 0xB5
	inMemoryValue := bus.Read(0xFF77)
	if inMemoryValue != 0xB5 {
		t.Errorf("[0xF0_LDH__a8_A_TC13_CHK_1] Error> LDH (a8), A instruction: the memory location @0x77 should have been set to 0xB5, got 0x%02X \n", inMemoryValue)
	}

	// check if the flags are not impacted
	if finalState.F != 0xE5 {
		t.Errorf("[0xF0_LDH_A__a8_TC13_CHK_2] Error> LDH (a8), A instruction: the flags should not have been impacted, got 0x%02X \n", finalState.F)
	}

	postconditions()
}

// PUSH: should push the value from the source into the stack
func TestPUSH(t *testing.T) {
	t.Skip("not implemented yet")
}

// POP: should pop the value from the stack into the destination
func TestPOP(t *testing.T) {
	t.Skip("not implemented yet")
}

// ADD: should add the value from the source to the destination
func TestADD(t *testing.T) {
	t.Skip("not implemented yet")
}

// ADC: should add the value from the source to the destination with the carry
func TestADC(t *testing.T) {
	t.Skip("not implemented yet")
}

// AND: should perform a bitwise AND between the source and the destination
func TestAND(t *testing.T) {
	t.Skip("not implemented yet")
}

// INC: Increment register or memory @[HL]
// opcodes:
//   - 0x3C=INC A
//   - 0x04=INC B
//   - 0x0C=INC C
//   - 0x14=INC D
//   - 0x1C=INC E
//   - 0x24=INC H
//   - 0x2C=INC L
//   - 0x34=INC [HL]
//   - 0x03=INC BC
//   - 0x13=INC DE
//   - 0x23=INC HL
//   - 0x33=INC SP
//
// flags: Z:Z N:0 H:H C:-
func TestINC(t *testing.T) {
	t.Run("0x3C: INC A", test_0x3C_INC_A)
	t.Run("0x04: INC B", test_0x04_INC_B)
	t.Run("0x0C: INC C", test_0x0C_INC_C)
	t.Run("0x14: INC D", test_0x14_INC_D)
	t.Run("0x1C: INC E", test_0x1C_INC_E)
	t.Run("0x24: INC H", test_0x24_INC_H)
	t.Run("0x2C: INC L", test_0x2C_INC_L)
	t.Run("0x34: INC [HL]", test_0x34_INC_HL)
	t.Run("0x03: INC BC", test_0x03_INC_BC)
	t.Run("0x13: INC DE", test_0x13_INC_DE)
	t.Run("0x23: INC HL", test_0x23_INC_HL)
	t.Run("0x33: INC SP", test_0x33_INC_SP)
}
func test_0x3C_INC_A(t *testing.T) {
	// TC 1: increment register A 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.a = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x3C_INC_A] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register A = 0x77
	if cpu.a != 0x77 {
		t.Errorf("[test_0x3C_INC_A] Error> the value of register A should have been set to 0x77, got 0x%02X \n", cpu.a)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register A from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.a = 0x000F

	testData2 := []uint8{0x3C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x3C_INC_A] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value at [HL] = 0x10
	if cpu.a != 0x10 {
		t.Errorf("[test_0x3C_INC_A] Error> the value of register A should have been set to 0x10, got 0x%02X \n", cpu.a)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing [HL] from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.a = 0x00FF

	testData3 := []uint8{0x3C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x3C_INC_A] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register A = 0x00
	if cpu.a != 0x00 {
		t.Errorf("[test_0x3C_INC_A] Error> the valueof register A should have been set to 0x00, got 0x%02X \n", cpu.a)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x3C_INC_A] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x04_INC_B(t *testing.T) {
	// TC 1: increment register B 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.b = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x04_INC_B] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x77
	if cpu.b != 0x77 {
		t.Errorf("[test_0x04_INC_B] Error> the value of register B should have been set to 0x77, got 0x%02X \n", cpu.b)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register B from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.b = 0x000F

	testData2 := []uint8{0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x04_INC_B] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x10
	if cpu.b != 0x10 {
		t.Errorf("[test_0x04_INC_B] Error> the value of register B should have been set to 0x10, got 0x%02X \n", cpu.b)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register B from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.b = 0x00FF

	testData3 := []uint8{0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x04_INC_B] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x00
	if cpu.b != 0x00 {
		t.Errorf("[test_0x04_INC_B] Error> the valueof register B should have been set to 0x00, got 0x%02X \n", cpu.b)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x04_INC_B] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x0C_INC_C(t *testing.T) {
	// TC 1: increment register C 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.c = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x0C_INC_C] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register C = 0x77
	if cpu.c != 0x77 {
		t.Errorf("[test_0x0C_INC_C] Error> the value of register C should have been set to 0x77, got 0x%02X \n", cpu.c)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register C from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.c = 0x000F

	testData2 := []uint8{0x0C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x0C_INC_C] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register C = 0x10
	if cpu.c != 0x10 {
		t.Errorf("[test_0x0C_INC_C] Error> the value of register C should have been set to 0x10, got 0x%02X \n", cpu.c)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register C from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.c = 0x00FF

	testData3 := []uint8{0x0C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x0C_INC_C] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register C = 0x00
	if cpu.c != 0x00 {
		t.Errorf("[test_0x0C_INC_C] Error> the valueof register C should have been set to 0x00, got 0x%02X \n", cpu.c)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x0C_INC_C] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x14_INC_D(t *testing.T) {
	// TC 1: increment register D 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.d = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x14_INC_D] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register D = 0x77
	if cpu.d != 0x77 {
		t.Errorf("[test_0x14_INC_D] Error> the value of register D should have been set to 0x77, got 0x%02X \n", cpu.d)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register D from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.d = 0x000F

	testData2 := []uint8{0x14, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x14_INC_D] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register D = 0x10
	if cpu.d != 0x10 {
		t.Errorf("[test_0x14_INC_D] Error> the value of register D should have been set to 0x10, got 0x%02X \n", cpu.d)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register D from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.d = 0x00FF

	testData3 := []uint8{0x14, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x14_INC_D] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register D = 0x00
	if cpu.d != 0x00 {
		t.Errorf("[test_0x14_INC_D] Error> the valueof register D should have been set to 0x00, got 0x%02X \n", cpu.d)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x14_INC_D] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x1C_INC_E(t *testing.T) {
	// TC 1: increment register E 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.e = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x1C_INC_E] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register E = 0x77
	if cpu.e != 0x77 {
		t.Errorf("[test_0x1C_INC_E] Error> the value of register E should have been set to 0x77, got 0x%02X \n", cpu.e)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register E from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.e = 0x000F

	testData2 := []uint8{0x1C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x1C_INC_E] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register E = 0x10
	if cpu.e != 0x10 {
		t.Errorf("[test_0x1C_INC_E] Error> the value of register E should have been set to 0x10, got 0x%02X \n", cpu.e)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register E from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.e = 0x00FF

	testData3 := []uint8{0x1C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x1C_INC_E] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register E = 0x00
	if cpu.e != 0x00 {
		t.Errorf("[test_0x1C_INC_E] Error> the valueof register E should have been set to 0x00, got 0x%02X \n", cpu.e)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x1C_INC_E] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x24_INC_H(t *testing.T) {
	// TC 1: increment register H 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.h = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x24_INC_H] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register H = 0x77
	if cpu.h != 0x77 {
		t.Errorf("[test_0x24_INC_H] Error> the value of register H should have been set to 0x77, got 0x%02X \n", cpu.h)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register H from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.h = 0x000F

	testData2 := []uint8{0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x24_INC_H] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register H = 0x10
	if cpu.h != 0x10 {
		t.Errorf("[test_0x24_INC_H] Error> the value of register H should have been set to 0x10, got 0x%02X \n", cpu.h)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register H from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.h = 0x00FF

	testData3 := []uint8{0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x24_INC_H] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register H = 0x00
	if cpu.h != 0x00 {
		t.Errorf("[test_0x24_INC_H] Error> the valueof register H should have been set to 0x00, got 0x%02X \n", cpu.h)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x2C_INC_L(t *testing.T) {
	// TC 1: increment register L 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.l = 0x0071
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x2C_INC_L] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register H = 0x77
	if cpu.l != 0x77 {
		t.Errorf("[test_0x2C_INC_L] Error> the value of register L should have been set to 0x77, got 0x%02X \n", cpu.l)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register L from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.l = 0x000F

	testData2 := []uint8{0x2C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x2C_INC_L] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register H = 0x10
	if cpu.l != 0x10 {
		t.Errorf("[test_0x2C_INC_L] Error> the value of register L should have been set to 0x10, got 0x%02X \n", cpu.l)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register L from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.l = 0x00FF

	testData3 := []uint8{0x2C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x2C_INC_L] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register H = 0x00
	if cpu.l != 0x00 {
		t.Errorf("[test_0x2C_INC_L] Error> the valueof register L should have been set to 0x00, got 0x%02X \n", cpu.l)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x2C_INC_L] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x24_INC_H] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x34_INC_HL(t *testing.T) {
	// TC 1: increment [HL] 6 times from 0x71 to 0x77 and stop @0x0006
	preconditions()

	cpu.setHL(0x0007)
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x10, 0x71}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x34_INC_HL] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value at [HL] = 0x77
	if bus.Read(0x0007) != 0x77 {
		t.Errorf("[test_0x34_INC_HL] Error> the value at [HL] should have been set to 0x77, got 0x%02X \n", bus.Read(0x0007))
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing [HL] from 0x0F to 0x10 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setHL(0x0007)

	testData2 := []uint8{0x34, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x34_INC_HL] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value at [HL] = 0x10
	if bus.Read(0x0007) != 0x10 {
		t.Errorf("[test_0x34_INC_HL] Error> the value at [HL] should have been set to 0x10, got 0x%02X \n", bus.Read(0x0007))
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing [HL] from 0xFF to 0x00 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setHL(0x0007)

	testData3 := []uint8{0x34, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x34_INC_HL] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value at [HL] = 0x00
	if bus.Read(0x0007) != 0x00 {
		t.Errorf("[test_0x34_INC_HL] Error> the value at [HL] should have been set to 0x00, got 0x%02X \n", bus.Read(0x0007))
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x34_INC_HL] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x03_INC_BC(t *testing.T) {
	// TC 1: increment register BC 6 times from 0xFF71 to 0xFF77 and stop @0x0006
	preconditions()

	cpu.setBC(0xFF71)
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x03_INC_BC] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register BC = 0xFF77
	if cpu.getBC() != 0xFF77 {
		t.Errorf("[test_0x03_INC_BC] Error> the value of register BC should have been set to 0xFF77, got 0x%04X \n", cpu.getBC())
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register BC from 0x00FF to 0x0100 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setBC(0x00FF)

	testData2 := []uint8{0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x03_INC_BC] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x0100
	if cpu.getBC() != 0x0100 {
		t.Errorf("[test_0x03_INC_BC] Error> the value of register BC should have been set to 0x10, got 0x%04X \n", cpu.getBC())
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register BC from 0xFFFF to 0x0000 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setBC(0xFFFF)

	testData3 := []uint8{0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x03_INC_BC] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register BC = 0x0000
	if cpu.getBC() != 0x0000 {
		t.Errorf("[test_0x03_INC_BC] Error> the valueof register BC should have been set to 0x00, got 0x%04X \n", cpu.getBC())
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x03_INC_BC] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x13_INC_DE(t *testing.T) {
	// TC 1: increment register DE 6 times from 0xFF71 to 0xFF77 and stop @0x0006
	preconditions()

	cpu.setDE(0xFF71)
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x13_INC_DE] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register BC = 0xFF77
	if cpu.getDE() != 0xFF77 {
		t.Errorf("[test_0x13_INC_DE] Error> the value of register DE should have been set to 0xFF77, got 0x%04X \n", cpu.getDE())
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register DE from 0x00FF to 0x0100 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setDE(0x00FF)

	testData2 := []uint8{0x13, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x13_INC_DE] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x0100
	if cpu.getDE() != 0x0100 {
		t.Errorf("[test_0x13_INC_DE] Error> the value of register DE should have been set to 0x10, got 0x%04X \n", cpu.getDE())
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register DE from 0xFFFF to 0x0000 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setDE(0xFFFF)

	testData3 := []uint8{0x13, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x13_INC_DE] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register BC = 0x0000
	if cpu.getDE() != 0x0000 {
		t.Errorf("[test_0x13_INC_DE] Error> the valueof register DE should have been set to 0x00, got 0x%04X \n", cpu.getDE())
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x13_INC_DE] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x23_INC_HL(t *testing.T) {
	// TC 1: increment register HL 6 times from 0xFF71 to 0xFF77 and stop @0x0006
	preconditions()

	cpu.setHL(0xFF71)
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x23_INC_HL] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register BC = 0xFF77
	if cpu.getHL() != 0xFF77 {
		t.Errorf("[test_0x23_INC_HL] Error> the value of register DE should have been set to 0xFF77, got 0x%04X \n", cpu.getHL())
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register HL from 0x00FF to 0x0100 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setHL(0x00FF)

	testData2 := []uint8{0x23, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x23_INC_HL] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x0100
	if cpu.getHL() != 0x0100 {
		t.Errorf("[test_0x23_INC_HL] Error> the value of register HL should have been set to 0x10, got 0x%04X \n", cpu.getHL())
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register HL from 0xFFFF to 0x0000 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.setHL(0xFFFF)

	testData3 := []uint8{0x23, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x23_INC_HL] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register BC = 0x0000
	if cpu.getHL() != 0x0000 {
		t.Errorf("[test_0x23_INC_HL] Error> the valueof register HL should have been set to 0x00, got 0x%04X \n", cpu.getHL())
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x23_INC_HL] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}
func test_0x33_INC_SP(t *testing.T) {
	// TC 1: increment register SP 6 times from 0xFF71 to 0xFF77 and stop @0x0006
	preconditions()

	cpu.sp = 0xFF71
	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()

	testData1 := []uint8{0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x10, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData1)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0006 {
		t.Errorf("[test_0x33_INC_SP] Error> the program counter should have stopped at 0x0006, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register SP = 0xFF77
	if cpu.sp != 0xFF77 {
		t.Errorf("[test_0x33_INC_SP] Error> the value of register SP should have been set to 0xFF77, got 0x%04X \n", cpu.sp)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is reset
	if cpu.getHFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the H flag should have been reset, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC2: check H flag (Z:Z N:0 H:H C:-) by incrementing register SP from 0x00FF to 0x0100 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.sp = 0x00FF

	testData2 := []uint8{0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData2)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x33_INC_SP] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register B = 0x0100
	if cpu.sp != 0x0100 {
		t.Errorf("[test_0x33_INC_SP] Error> the value of register SP should have been set to 0x10, got 0x%04X \n", cpu.sp)
	}

	// check that Z flag is not set
	if cpu.getZFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the Z flag should have been reset, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the N flag should have been reset, got %t \n", cpu.getNFlag())
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the C flag should have been left untouched, got %t \n", cpu.getCFlag())
	}

	postconditions()

	// TC3: check Z & H flags (Z:Z N:0 H:H C:-) by incrementing register SP from 0xFFFF to 0x0000 and stop @0x0001
	preconditions()

	cpu.resetZFlag()
	cpu.setNFlag()
	cpu.resetHFlag()
	cpu.setCFlag()
	cpu.sp = 0xFFFF

	testData3 := []uint8{0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	loadProgramIntoMemory(memory1, testData3)
	cpu.Run()

	// check the final state of the cpu
	if cpu.pc != 0x0001 {
		t.Errorf("[test_0x33_INC_SP] Error> the program counter should have stopped at 0x0001, got 0x%04X \n", cpu.pc)
	}

	// check if the value of register SP = 0x0000
	if cpu.sp != 0x0000 {
		t.Errorf("[test_0x33_INC_SP] Error> the valueof register SP should have been set to 0x00, got 0x%04X \n", cpu.sp)
	}

	// check that Z flag is set
	if !cpu.getZFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the Z flag should have been set, got %t \n", cpu.getZFlag())
	}

	// check that N flag is reset
	if cpu.getNFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the N flag should have been reset \n")
	}

	// check if the H flag is set
	if !cpu.getHFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the H flag should have been set, got %t \n", cpu.getHFlag())
	}

	// check if C flag is left untouched
	if !cpu.getCFlag() {
		t.Errorf("[test_0x33_INC_SP] Error> the C flag should have been left untouched \n")
	}
	postconditions()
}

// CCF: should flip the carry flag
// 0x3F: CCF
// Complement Carry Flag: flip the value of the carry flag and reset the N and H flags
func TestCCF(t *testing.T) {
	preconditions()

	// set all flags to 1
	cpu.f = 0x00
	cpu.setZFlag()
	cpu.setNFlag()
	cpu.setHFlag()
	cpu.setCFlag()

	// save the initial state of the cpu
	initialState := getCpuState()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x3F, 0x00, 0x10}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the Z flag was left untouched (1)
	if finalState.Z != initialState.Z {
		t.Errorf("Expected Z flag to be 1")
	}

	// check if the N flag was reset
	if finalState.N != false {
		t.Errorf("Expected N flag to be 0")
	}

	// check if the H flag was reset
	if finalState.H != false {
		t.Errorf("Expected H flag to be 0")
	}

	// check if the C flag was set
	if finalState.C == true {
		t.Errorf("Expected C flag to be flipped")
	}
}

// CP: should compare the value from the source to the destination
func TestCP(t *testing.T) {
	t.Skip("not implemented yet")
}

// CPL: should flip all bits of the destination
func TestCPL(t *testing.T) {
	t.Skip("not implemented yet")
}

// DAA: should adjust the destination to be a valid BCD number
// 0x27: DAA
// Decimal Adjust Accumulator to get a correct BCD representation after an arithmetic instruction.
// The steps performed depend on the type of the previous operation: ADD or SUB
func TestDAA(t *testing.T) {
	// Test Cases
	type params struct {
		A uint8
		Z bool
		N bool
		H bool
		C bool
	}
	type testCase struct {
		initial  params
		expected params
	}
	testCases := []testCase{
		// TC0: A = 0x00, no flags set
		{initial: params{
			A: 0x55,
			Z: false,
			N: false,
			H: false,
			C: false,
		}, expected: params{
			A: 0x55,
			Z: false,
			N: false,
			H: false,
			C: false,
		}},
		// TC1: A = 0x0A, no flags set
		{initial: params{
			A: 0x0A,
			Z: false,
			N: false,
			H: false,
			C: false,
		}, expected: params{
			A: 0x10,
			Z: false,
			N: false,
			H: false,
			C: false,
		}},
		// TC2: A = 0x99, no flags set
		{initial: params{
			A: 0x99,
			Z: false,
			N: false,
			H: false,
			C: false,
		}, expected: params{
			A: 0x99,
			Z: false,
			N: false,
			H: false,
			C: false,
		}},
		// TC3: A = 0x42, no flags set
		{initial: params{
			A: 0x42,
			Z: false,
			N: false,
			H: false,
			C: false,
		}, expected: params{
			A: 0x42,
			Z: false,
			N: false,
			H: false,
			C: false,
		}},
		// TC4: A = 0x00, Z flag set
		{
			initial: params{
				A: 0x00,
				Z: true,
				N: false,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x00,
				Z: true,
				N: false,
				H: false,
				C: false,
			},
		},
		// TC5: A = 0x09, no flags set
		{
			initial: params{
				A: 0x09,
				Z: false,
				N: false,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x09,
				Z: false,
				N: false,
				H: false,
				C: false,
			},
		},
		// TC6: A = 0xA0, no flags set
		{
			initial: params{
				A: 0xA0,
				Z: false,
				N: false,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x00,
				Z: true,
				N: false,
				H: false,
				C: true,
			},
		},
		// TC7: A = 0x99, no flags set
		{
			initial: params{
				A: 0x99,
				Z: false,
				N: false,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x99,
				Z: false,
				N: false,
				H: false,
				C: false,
			},
		},
		// TC8: A=0x99+0x66=0xFF, no flags set
		{
			initial: params{
				A: 0xFF,
				Z: false,
				N: false,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x65,
				Z: false,
				N: false,
				H: false,
				C: true,
			},
		},
		// TC9: A=0x55-0x55=0x00, N flag set
		{
			initial: params{
				A: 0x00,
				Z: true,
				N: true,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x00,
				Z: true,
				N: true,
				H: false,
				C: false,
			},
		},
		// TC10
		{
			initial: params{
				A: 0x10,
				Z: false,
				N: true,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x10,
				Z: false,
				N: true,
				H: false,
				C: false,
			},
		},
		// TC11
		{
			initial: params{
				A: 0x99,
				Z: false,
				N: true,
				H: false,
				C: false,
			},
			expected: params{
				A: 0x99,
				Z: false,
				N: true,
				H: false,
				C: false,
			},
		},
		// TC12: A=0x00-0x01=0xFF, N & C flags set
		{
			initial: params{
				A: 0xFF,
				Z: false,
				N: true,
				H: false,
				C: true,
			},
			expected: params{
				A: 0x05,
				Z: false,
				N: true,
				H: false,
				C: true,
			},
		},
	}

	for tci, tc := range testCases {
		preconditions()

		// set the A register to 10 = 0x0A
		cpu.a = tc.initial.A

		// Set flags
		if tc.initial.Z {
			cpu.setZFlag() // to confirm that Z is reset if the result is not 0
		} else {
			cpu.resetZFlag() // to confirm that Z is reset
		}
		if tc.initial.N {
			cpu.setNFlag() // last operation was an addition
		} else {
			cpu.resetNFlag() // last operation was a subtraction
		}
		if tc.initial.H {
			cpu.setHFlag() // to confirm that H is reset
		} else {
			cpu.resetHFlag() // to confirm that H is reset
		}
		if tc.initial.C {
			cpu.setCFlag() // to confirm that C is reset
		} else {
			cpu.resetCFlag() // to confirm that C is reset
		}

		// Execute the instruction
		cpu.executeInstruction(GetInstruction("0x27", false))

		// check if the program counter was incremented by instruction.Length
		//if cpu.pc != cpuCopy.PC+1 {
		//	t.Errorf("TC%v> Expected PC to be %v, got %v", tci, cpuCopy.PC+1, cpu.pc)
		//}

		// check if the A register now contains the correct BCD representation of 10 (0x10)
		if cpu.a != tc.expected.A {
			t.Errorf("TC%v> Expected A to be 0x%02X, got 0x%02X", tci, tc.expected.A, cpu.a)
		}

		// check flags
		if cpu.getZFlag() != tc.expected.Z {
			t.Errorf("TC%v> Expected Z flag to be %t", tci, tc.expected.Z)
		}
		if cpu.getNFlag() != tc.expected.N {
			t.Errorf("TC%v> Expected N flag to be %t", tci, tc.expected.N)
		}
		if cpu.getHFlag() != tc.expected.H {
			t.Errorf("TC%v> Expected H flag to be %t", tci, tc.expected.H)
		}
		if cpu.getCFlag() != tc.expected.C {
			t.Errorf("TC%v> Expected C flag to be %t", tci, tc.expected.C)
		}
		postconditions()
	}
}

// DEC: should decrement the value of the destination
func TestDEC(t *testing.T) {
	t.Skip("not implemented yet")
}

// SUB: should subtract the value from the source to the destination
func TestSUB(t *testing.T) {
	t.Skip("not implemented yet")
}

// SBC: should subtract the value from the source to the destination with the carry
func TestSBC(t *testing.T) {
	t.Skip("not implemented yet")
}

// SCF: should set the carry flag
// 0x37: SCF
// Set Carry Flag: set the carry flag to 1 and reset the N and H flags
func TestSCF(t *testing.T) {
	preconditions()

	// set all flags to see if they are all correctly reset and have C flag set to be rotated in register A
	cpu.f = 0x00
	cpu.setZFlag()
	cpu.setNFlag()
	cpu.setHFlag()

	// reset the carry flag
	cpu.setCFlag()

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x37, 0x00, 0x10}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// check if the Z flag was left untouched (1)
	if finalState.Z != true {
		t.Errorf("Expected Z flag to be 1")
	}

	// check if the N flag was reset
	if finalState.N != false {
		t.Errorf("Expected N flag to be 0")
	}

	// check if the H flag was reset
	if finalState.H != false {
		t.Errorf("Expected H flag to be 0")
	}

	// check if the C flag was set
	if finalState.C != true {
		t.Errorf("Expected C flag to be 1")
	}

	postconditions()
}

// TC28: should perform a bitwise OR between the source and the destination
func TestOR(t *testing.T) {
	t.Skip("not implemented yet")
}

// XOR: should perform a bitwise XOR between the source and the destination
// opcodes
// 	- 0xA8: XOR A, B
// 	- 0xA9: XOR A, C
// 	- 0xAA: XOR A, D
// 	- 0xAB: XOR A, E
// 	- 0xAC: XOR A, H
// 	- 0xAD: XOR A, L
// 	- 0xAE: XOR A, (HL)
// 	- 0xAF: XOR A, A
// 	- 0xEE: XOR A, n8
// flags: Z:Z N:0 H:0 C:0

func TestXOR(t *testing.T) {
	t.Run("0xA8_XOR_A_B", test_0xA8_XOR_A_B)
	t.Run("0xA9_XOR_A_C", test_0xA9_XOR_A_C)
	t.Run("0xAA_XOR_A_D", test_0xAA_XOR_A_D)
	t.Run("0xAB_XOR_A_E", test_0xAB_XOR_A_E)
	t.Run("0xAC_XOR_A_H", test_0xAC_XOR_A_H)
	t.Run("0xAD_XOR_A_L", test_0xAD_XOR_A_L)
	t.Run("0xAE_XOR_A_HL", test_0xAE_XOR_A_HL)
	t.Run("0xAF_XOR_A_A", test_0xAF_XOR_A_A)
	t.Run("0xEE_XOR_A_n8", test_0xEE_XOR_A_n8)
}
func test_0xA8_XOR_A_B(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.b = data[1]
		expected := data[2]
		testProgram := []uint8{0xA8, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xA8_XOR_A_B] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xA8_XOR_A_B] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xA8_XOR_A_B] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xA8_XOR_A_B] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xA9_XOR_A_C(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.c = data[1]
		expected := data[2]
		testProgram := []uint8{0xA9, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xA9_XOR_A_C] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xA9_XOR_A_C] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xA9_XOR_A_C] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xA9_XOR_A_C] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xAA_XOR_A_D(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.d = data[1]
		expected := data[2]
		testProgram := []uint8{0xAA, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xAA_XOR_A_D] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xAA_XOR_A_D] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xAA_XOR_A_D] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xAA_XOR_A_D] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xAB_XOR_A_E(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.e = data[1]
		expected := data[2]
		testProgram := []uint8{0xAB, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xAB_XOR_A_E] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xAB_XOR_A_E] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xAB_XOR_A_E] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xAB_XOR_A_E] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xAC_XOR_A_H(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.h = data[1]
		expected := data[2]
		testProgram := []uint8{0xAC, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xAC_XOR_A_H] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xAC_XOR_A_H] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xAC_XOR_A_H] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xAC_XOR_A_H] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xAD_XOR_A_L(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.l = data[1]
		expected := data[2]
		testProgram := []uint8{0xAD, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xAD_XOR_A_L] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xAD_XOR_A_L] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xAD_XOR_A_L] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xAD_XOR_A_L] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xAE_XOR_A_HL(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		cpu.setHL(0x0002)
		expected := data[2]
		testProgram := []uint8{0xAE, 0x10, data[1]}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xAE_XOR_A_HL] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != expected {
			t.Errorf("[test_0xAE_XOR_A_HL] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xAE_XOR_A_HL] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xAE_XOR_A_HL] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}
func test_0xAF_XOR_A_A(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		expected := data[2]
		testProgram := []uint8{0xAF, 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0001 {
			t.Errorf("[test_0xAF_XOR_A_A] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}

		if cpu.a != 0x00 {
			t.Errorf("[test_0xAF_XOR_A_A] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if cpu.f != 0x80 {
			t.Errorf("[test_0xAF_XOR_A_A] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
		}
	}
}
func test_0xEE_XOR_A_n8(t *testing.T) {
	testData := [][3]uint8{
		{0b00000000, 0b00000000, 0b00000000},
		{0b11111111, 0b11111111, 0b00000000},
		{0b01010101, 0b10101010, 0b11111111},
		{0b10101010, 0b01010101, 0b11111111},
		{0b00001111, 0b11110000, 0b11111111},
		{0b00001111, 0b00001111, 0b00000000},
		{0b11110000, 0b00001111, 0b11111111},
		{0b11110000, 0b11110000, 0b00000000},
		{0b00110011, 0b11001100, 0b11111111},
		{0b11001100, 0b00110011, 0b11111111},
		{0b00110011, 0b00110011, 0b00000000},
		{0b11001100, 0b11001100, 0b00000000},
		{0b01101001, 0b11110100, 0b10011101},
	}

	for idx, data := range testData {
		preconditions()
		cpu.f = 0xF0
		cpu.a = data[0]
		expected := data[2]
		testProgram := []uint8{0xEE, data[1], 0x10}
		loadProgramIntoMemory(memory1, testProgram)
		cpu.Run()

		if cpu.pc != 0x0002 {
			t.Errorf("[test_0xEE_XOR_A_n8] TC%v> Expected PC to be 0x0001, got 0x%04X", idx, cpu.pc)
		}
		if cpu.a != expected {
			t.Errorf("[test_0xEE_XOR_A_n8] TC%v> Expected A to be 0x%02X, got 0x%02X", idx, expected, cpu.a)
		}
		if expected == 0x00 {
			if cpu.f != 0x80 {
				t.Errorf("[test_0xEE_XOR_A_n8] TC%v> Expected flags to be reset except Z flag, got 0x%02X", idx, cpu.f)
			}
		} else {
			if cpu.f != 0x00 {
				t.Errorf("[test_0xEE_XOR_A_n8] TC%v> Expected flags to be reset, got 0x%02X", idx, cpu.f)
			}
		}
	}
}

// RLA: should rotate the destination left through the carry
// 0x17: RLA rotates the A register to the left through the carry flag
// The 0th bit of the A register should be set to the value of the carry flag
// The carry flag should be set to the value of the 7th bit of the A register
// All other flags should be reset
func TestRLA(t *testing.T) {
	preconditions()

	// set all flags to see if they are all correctly reset and have C flag set to be rotated in register A
	cpu.f = 0x00

	cpu.setZFlag()
	cpu.setNFlag()
	cpu.setHFlag()
	cpu.setCFlag()

	// set the A register to b 0101 0101
	cpu.a = 0x55

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x17, 0x00, 0x10}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	fmt.Println("Z:", finalState.Z, "N:", finalState.N, "H:", finalState.H, "C:", finalState.C)

	// check if the A register was rotated left giving 0xAB
	if finalState.A != 0xAB {
		t.Errorf("[RLA_TC30_CHK_1] Error> RLA instruction: the A register should have been set to 0xAB, got 0x%02X \n", finalState.A)
	}

	// check if the flags are set correctly
	if finalState.F != 0x00 {
		t.Errorf("[RLA_TC30_CHK_2] Error> RLA instruction: the flags should have been reset, got 0x%02X \n", finalState.F)
	}

	postconditions()
}

// RLCA: should rotate the destination left
// 0x07: RLCA rotates the A register to the left
// The carry flag should be set to the value of the 7th bit of the A register
// All other flags should be reset
func TestRLCA(t *testing.T) {
	preconditions()

	// set all flags to 1 to see if they are reset
	cpu.f = 0x00
	cpu.setZFlag()
	cpu.setNFlag()
	cpu.setHFlag()

	// reset the carry flag
	cpu.resetCFlag()

	// set the A register to b10101010
	cpu.a = 0xAA

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x07, 0x00, 0x10}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	if finalState.A != 0x55 {
		t.Errorf("Expected A to be 0x55, got 0x%02X", finalState.A)
	}

	// check if the C flag was set
	if cpu.getCFlag() != true {
		t.Errorf("Expected C flag to be set")
	}

	// check if the Z, N and H flags were reset
	if cpu.getZFlag() != false {
		t.Errorf("Expected Z flag to be reset")
	}
	if cpu.getNFlag() != false {
		t.Errorf("Expected N flag to be reset")
	}
	if cpu.getHFlag() != false {
		t.Errorf("Expected H flag to be reset")
	}

	postconditions()
}

// RRA: should rotate the destination right through the carry
// 0x1F: RRA rotates the A register to the right through the carry flag
// The 7th bit of the A register should be set to the value of the carry flag
// The carry flag should be set to the value of the 0th bit of the A register
// All other flags should be reset
func TestRRA(t *testing.T) {
	preconditions()

	// set all flags to 1 to see if they are reset
	cpu.f = 0x00
	cpu.setZFlag()
	cpu.setNFlag()
	cpu.setHFlag()
	cpu.setCFlag()

	// set the A register to b10101010
	cpu.a = 0xAA

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x1F, 0x00, 0x10}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	// 1010 1010 => 1101 0101 (0xD5)
	if finalState.A != 0xD5 {
		t.Errorf("Expected A to be 0xD5, got 0x%02X", finalState.A)
	}

	// check if the carry flag was reset
	if cpu.getCFlag() != false {
		t.Errorf("Expected C flag to be reset")
	}

	// check if the Z, N and H flags were reset
	if cpu.getZFlag() != false {
		t.Errorf("Expected Z flag to be reset")
	}
	if cpu.getNFlag() != false {
		t.Errorf("Expected N flag to be reset")
	}
	if cpu.getHFlag() != false {
		t.Errorf("Expected H flag to be reset")
	}
}

// RRCA: should rotate the destination right
// 0x0F: RRCA rotates the A register to the right
// The carry flag should be set to the value of the 0th bit of the A register
// All other flags should be reset
func TestRRCA(t *testing.T) {
	preconditions()

	// set all flags to 1 to see if they are reset
	cpu.f = 0x00
	cpu.setZFlag()
	cpu.setNFlag()
	cpu.setHFlag()

	// reset the carry flag
	cpu.resetCFlag()

	// set the A register to b10101010
	cpu.a = 0x55

	// load the program into the memory
	testData := []uint8{0x00, 0x00, 0x00, 0x0F, 0x00, 0x10}
	loadProgramIntoMemory(memory1, testData)

	// run the program
	cpu.Run()

	// check the final state of the cpu
	finalState := getCpuState()

	if finalState.A != 0xAA {
		t.Errorf("Expected A to be 0xAA, got 0x%02X", finalState.A)
	}

	// check if the carry flag was set
	if cpu.getCFlag() != true {
		t.Errorf("Expected C flag to be set")
	}

	// check if the Z, N and H flags were reset
	if cpu.getZFlag() != false {
		t.Errorf("Expected Z flag to be reset")
	}
	if cpu.getNFlag() != false {
		t.Errorf("Expected N flag to be reset")
	}
	if cpu.getHFlag() != false {
		t.Errorf("Expected H flag to be reset")
	}

	postconditions()
}
